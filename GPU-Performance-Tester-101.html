<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPU Performance Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            padding: 20px;
            color: #fff;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-start {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(45deg, #f44336, #da190b);
            color: white;
        }

        .btn-reset {
            background: linear-gradient(45deg, #ff9800, #f57c00);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .test-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.3s ease;
        }

        .test-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }

        .test-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }

        .thread-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 8px;
        }

        .thread-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 8px;
            text-align: center;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }

        .thread-item.waiting {
            background: rgba(128, 128, 128, 0.2);
            border-color: rgba(128, 128, 128, 0.4);
        }

        .thread-item.executing {
            background: rgba(255, 193, 7, 0.25);
            border-color: rgba(255, 193, 7, 0.7);
            animation: pulse 1.5s infinite;
        }

        .thread-item.done {
            background: rgba(76, 175, 80, 0.25);
            border-color: rgba(76, 175, 80, 0.7);
        }

        .thread-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 4px;
        }

        .thread-time {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4CAF50;
        }

        .thread-status {
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .thread-status.waiting {
            color: #9E9E9E;
        }

        .thread-status.executing {
            color: #FFC107;
        }

        .thread-status.done {
            color: #4CAF50;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
        }

        .status {
            text-align: center;
            margin-top: 10px;
            font-weight: 500;
        }

        .summary {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            text-align: center;
        }

        .summary h2 {
            margin-bottom: 20px;
            font-size: 1.5rem;
        }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
            gap: 12px;
        }

        .summary-item {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 12px;
            transition: all 0.3s ease;
        }

        .summary-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }

        .summary-label {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .summary-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: #4CAF50;
            text-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .running {
            animation: pulse 1.5s infinite;
        }

        .gpu-info {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            text-align: center;
        }

        .gpu-info h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }

        canvas {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéÆ GPU Performance Tester</h1>
            <p>Parallel processing performance analysis using WebGL compute shaders</p>
            <p style="font-size: 0.9rem; opacity: 0.8; margin-top: 5px;">
                Each test runs for exactly 7 seconds. Tests parallel shader invocations. All test types are weighted equally in the combined totals. Higher numbers = better performance.
            </p>
        </div>

        <div class="gpu-info">
            <h3>üñ•Ô∏è GPU Information</h3>
            <p id="gpuInfo">Detecting GPU...</p>
        </div>

        <div class="controls">
            <button class="btn btn-start" id="startBtn">‚ñ∂Ô∏è Start Test</button>
            <button class="btn btn-stop" id="stopBtn" disabled>‚èπÔ∏è Stop Test</button>
            <button class="btn btn-reset" id="resetBtn">üîÑ Reset</button>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="overallProgress"></div>
            </div>
            <div class="status" id="statusText">Ready to start testing</div>
        </div>

        <div class="test-grid">
            <div class="test-card">
                <div class="test-title">üî¢ Vector Operations</div>
                <div class="thread-results" id="vectorResults"></div>
            </div>

            <div class="test-card">
                <div class="test-title">üßÆ Matrix Multiply</div>
                <div class="thread-results" id="matrixResults"></div>
            </div>

            <div class="test-card">
                <div class="test-title">üåä Texture Processing</div>
                <div class="thread-results" id="textureResults"></div>
            </div>

            <div class="test-card">
                <div class="test-title">‚ö° Parallel Compute</div>
                <div class="thread-results" id="computeResults"></div>
            </div>
        </div>

        <div class="summary">
            <h2>üî• Combined Performance Totals</h2>
            <div class="summary-stats">
                <div class="summary-item">
                    <div class="summary-label">100 Shaders</div>
                    <div class="summary-value" id="total-100">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">250 Shaders</div>
                    <div class="summary-value" id="total-250">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">500 Shaders</div>
                    <div class="summary-value" id="total-500">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">1K Shaders</div>
                    <div class="summary-value" id="total-1000">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">2.5K Shaders</div>
                    <div class="summary-value" id="total-2500">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">5K Shaders</div>
                    <div class="summary-value" id="total-5000">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">10K Shaders</div>
                    <div class="summary-value" id="total-10000">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">25K Shaders</div>
                    <div class="summary-value" id="total-25000">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">50K Shaders</div>
                    <div class="summary-value" id="total-50000">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">100K Shaders</div>
                    <div class="summary-value" id="total-100000">-</div>
                </div>
            </div>
        </div>
    </div>

    <canvas id="webglCanvas" width="1024" height="1024"></canvas>

    <script>
        class GPUPerformanceTester {
            constructor() {
                this.shaderCounts = [100, 250, 500, 1000, 2500, 5000, 10000, 25000, 50000, 100000];
                this.isRunning = false;
                this.results = {
                    vector: {},
                    matrix: {},
                    texture: {},
                    compute: {}
                };
                this.currentTest = '';
                this.currentShaders = 0;
                this.totalTests = this.shaderCounts.length * 4;
                this.completedTests = 0;

                // Normalization factors for equal contribution
                this.normalizationFactors = {
                    vector: 1,      // Baseline
                    matrix: 5,      // Matrix ops are more intensive
                    texture: 0.5,   // Texture ops produce more results
                    compute: 2      // Parallel compute scaling
                };

                this.initializeElements();
                this.initializeWebGL();
                this.initializeResultsDisplay();
                this.bindEvents();
            }

            initializeElements() {
                this.startBtn = document.getElementById('startBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.resetBtn = document.getElementById('resetBtn');
                this.statusText = document.getElementById('statusText');
                this.overallProgress = document.getElementById('overallProgress');
                this.gpuInfo = document.getElementById('gpuInfo');
            }

            initializeWebGL() {
                this.canvas = document.getElementById('webglCanvas');
                this.gl = this.canvas.getContext('webgl2') || this.canvas.getContext('webgl');
                
                if (!this.gl) {
                    this.gpuInfo.textContent = 'WebGL not supported - GPU testing unavailable';
                    this.startBtn.disabled = true;
                    return;
                }

                // Get GPU info
                const debugInfo = this.gl.getExtension('WEBGL_debug_renderer_info');
                if (debugInfo) {
                    const vendor = this.gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                    const renderer = this.gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                    this.gpuInfo.textContent = `${vendor} - ${renderer}`;
                } else {
                    this.gpuInfo.textContent = 'GPU information not available';
                }

                this.initializeShaders();
            }

            initializeShaders() {
                // Vertex shader for all compute operations
                const vertexShaderSource = `
                    attribute vec2 position;
                    varying vec2 texCoord;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                        texCoord = (position + 1.0) / 2.0;
                    }
                `;

                // Fragment shader for vector operations
                const vectorFragmentShader = `
                    precision mediump float;
                    varying vec2 texCoord;
                    uniform float time;
                    uniform float iterations;
                    
                    void main() {
                        vec2 coord = texCoord * iterations;
                        float result = 0.0;
                        
                        for(float i = 0.0; i < 100.0; i++) {
                            if(i >= iterations) break;
                            vec2 pos = coord + vec2(i * 0.01, time * 0.001);
                            result += sin(pos.x * 10.0) * cos(pos.y * 10.0);
                            result = mod(result * 1.1, 1.0);
                        }
                        
                        gl_FragColor = vec4(result, result * 0.5, result * 0.3, 1.0);
                    }
                `;

                // Fragment shader for matrix operations
                const matrixFragmentShader = `
                    precision mediump float;
                    varying vec2 texCoord;
                    uniform float time;
                    uniform float matrixSize;
                    
                    void main() {
                        vec2 coord = texCoord * matrixSize;
                        float result = 0.0;
                        
                        for(float i = 0.0; i < 64.0; i++) {
                            if(i >= matrixSize) break;
                            for(float j = 0.0; j < 64.0; j++) {
                                if(j >= matrixSize) break;
                                float a = sin(coord.x + i * 0.1 + time * 0.001);
                                float b = cos(coord.y + j * 0.1 + time * 0.001);
                                result += a * b;
                            }
                        }
                        
                        result = mod(result * 0.1, 1.0);
                        gl_FragColor = vec4(result, result * 0.7, result * 0.4, 1.0);
                    }
                `;

                // Fragment shader for texture processing
                const textureFragmentShader = `
                    precision mediump float;
                    varying vec2 texCoord;
                    uniform float time;
                    uniform float complexity;
                    
                    void main() {
                        vec2 coord = texCoord * complexity;
                        vec3 color = vec3(0.0);
                        
                        for(float i = 0.0; i < 50.0; i++) {
                            if(i >= complexity) break;
                            vec2 offset = vec2(sin(time * 0.001 + i), cos(time * 0.001 + i)) * 0.1;
                            vec2 pos = coord + offset;
                            
                            float r = sin(pos.x * 5.0 + time * 0.002) * 0.5 + 0.5;
                            float g = cos(pos.y * 5.0 + time * 0.002) * 0.5 + 0.5;
                            float b = sin((pos.x + pos.y) * 3.0 + time * 0.002) * 0.5 + 0.5;
                            
                            color += vec3(r, g, b) * 0.02;
                        }
                        
                        gl_FragColor = vec4(color, 1.0);
                    }
                `;

                // Fragment shader for parallel compute
                const computeFragmentShader = `
                    precision mediump float;
                    varying vec2 texCoord;
                    uniform float time;
                    uniform float workload;
                    
                    float hash(vec2 p) {
                        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
                    }
                    
                    void main() {
                        vec2 coord = texCoord * workload;
                        float result = 0.0;
                        
                        for(float i = 0.0; i < 200.0; i++) {
                            if(i >= workload) break;
                            vec2 pos = coord + vec2(i * 0.01, time * 0.001);
                            result += hash(pos);
                            result = fract(result * 1.618);
                            
                            // Additional computation
                            result += sqrt(abs(sin(pos.x * 20.0) * cos(pos.y * 20.0)));
                            result = mod(result, 1.0);
                        }
                        
                        gl_FragColor = vec4(result, result * 0.8, result * 0.6, 1.0);
                    }
                `;

                this.programs = {
                    vector: this.createProgram(vertexShaderSource, vectorFragmentShader),
                    matrix: this.createProgram(vertexShaderSource, matrixFragmentShader),
                    texture: this.createProgram(vertexShaderSource, textureFragmentShader),
                    compute: this.createProgram(vertexShaderSource, computeFragmentShader)
                };

                // Create quad for rendering
                this.createQuad();
            }

            createProgram(vertexSource, fragmentSource) {
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentSource);
                
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program link error:', this.gl.getProgramInfoLog(program));
                    return null;
                }
                
                return program;
            }

            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));
                    return null;
                }
                
                return shader;
            }

            createQuad() {
                const vertices = new Float32Array([
                    -1, -1,
                     1, -1,
                    -1,  1,
                     1,  1
                ]);
                
                this.quadBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);
            }

            initializeResultsDisplay() {
                const resultContainers = ['vectorResults', 'matrixResults', 'textureResults', 'computeResults'];
                
                resultContainers.forEach(containerId => {
                    const container = document.getElementById(containerId);
                    container.innerHTML = '';
                    
                    this.shaderCounts.forEach(count => {
                        const threadItem = document.createElement('div');
                        threadItem.className = 'thread-item waiting';
                        
                        // Format shader count for display
                        let displayCount;
                        if (count >= 1000) {
                            displayCount = `${count / 1000}K`;
                        } else {
                            displayCount = count.toString();
                        }
                        
                        threadItem.innerHTML = `
                            <div class="thread-label">${displayCount} Shader${count > 1 ? 's' : ''}</div>
                            <div class="thread-status waiting" id="${containerId}-${count}-status">Waiting</div>
                            <div class="thread-time" id="${containerId}-${count}">-</div>
                        `;
                        container.appendChild(threadItem);
                    });
                });
            }

            bindEvents() {
                this.startBtn.addEventListener('click', () => this.startTests());
                this.stopBtn.addEventListener('click', () => this.stopTests());
                this.resetBtn.addEventListener('click', () => this.resetTests());
            }

            async startTests() {
                if (this.isRunning || !this.gl) return;
                
                this.isRunning = true;
                this.startBtn.disabled = true;
                this.stopBtn.disabled = false;
                this.completedTests = 0;
                
                try {
                    await this.runAllTests();
                    this.updateSummary();
                } catch (error) {
                    console.error('Test error:', error);
                } finally {
                    this.isRunning = false;
                    this.startBtn.disabled = false;
                    this.stopBtn.disabled = true;
                    this.statusText.textContent = 'Tests completed';
                    this.statusText.classList.remove('running');
                }
            }

            stopTests() {
                this.isRunning = false;
                this.startBtn.disabled = false;
                this.stopBtn.disabled = true;
                this.statusText.textContent = 'Tests stopped';
                this.statusText.classList.remove('running');
            }

            resetTests() {
                this.stopTests();
                this.results = {
                    vector: {},
                    matrix: {},
                    texture: {},
                    compute: {}
                };
                this.completedTests = 0;
                this.overallProgress.style.width = '0%';
                this.statusText.textContent = 'Ready to start testing';
                
                this.shaderCounts.forEach(count => {
                    ['vectorResults', 'matrixResults', 'textureResults', 'computeResults'].forEach(type => {
                        const calculationElement = document.getElementById(`${type}-${count}`);
                        const statusElement = document.getElementById(`${type}-${count}-status`);
                        const threadItem = calculationElement?.closest('.thread-item');
                        
                        if (calculationElement) calculationElement.textContent = '-';
                        if (statusElement) {
                            statusElement.textContent = 'Waiting';
                            statusElement.className = 'thread-status waiting';
                        }
                        if (threadItem) {
                            threadItem.className = 'thread-item waiting';
                        }
                    });
                });

                this.shaderCounts.forEach(count => {
                    const totalElement = document.getElementById(`total-${count}`);
                    if (totalElement) totalElement.textContent = '-';
                });
            }

            async runAllTests() {
                const tests = [
                    { name: 'vector', func: this.runVectorTest.bind(this), display: 'vectorResults' },
                    { name: 'matrix', func: this.runMatrixTest.bind(this), display: 'matrixResults' },
                    { name: 'texture', func: this.runTextureTest.bind(this), display: 'textureResults' },
                    { name: 'compute', func: this.runComputeTest.bind(this), display: 'computeResults' }
                ];

                for (const test of tests) {
                    if (!this.isRunning) break;
                    
                    this.currentTest = test.name;
                    this.statusText.textContent = `Running ${test.name} tests...`;
                    this.statusText.classList.add('running');
                    
                    for (const shaderCount of this.shaderCounts) {
                        if (!this.isRunning) break;
                        
                        this.currentShaders = shaderCount;
                        this.statusText.textContent = `Testing ${test.name} with ${shaderCount} shader${shaderCount > 1 ? 's' : ''}... (7s each)`;
                        
                        this.updateStatus(test.display, shaderCount, 'executing');
                        
                        const startTime = performance.now();
                        const operations = await test.func(shaderCount);
                        const endTime = performance.now();
                        
                        const duration = endTime - startTime;
                        
                        this.results[test.name][shaderCount] = {
                            time: duration,
                            operations: operations,
                            calculated: operations
                        };
                        
                        this.updateStatus(test.display, shaderCount, 'done');
                        this.updateDisplay(test.display, shaderCount, operations);
                        
                        this.completedTests++;
                        this.updateProgress();
                        
                        await new Promise(resolve => setTimeout(resolve, 200));
                    }
                }
            }

            async runVectorTest(shaderCount) {
                return this.runGPUTest('vector', shaderCount, {
                    iterations: Math.min(Math.max(shaderCount / 10, 10), 100)
                });
            }

            async runMatrixTest(shaderCount) {
                return this.runGPUTest('matrix', shaderCount, {
                    matrixSize: Math.min(Math.max(shaderCount / 50, 8), 64)
                });
            }

            async runTextureTest(shaderCount) {
                return this.runGPUTest('texture', shaderCount, {
                    complexity: Math.min(Math.max(shaderCount / 100, 5), 50)
                });
            }

            async runComputeTest(shaderCount) {
                return this.runGPUTest('compute', shaderCount, {
                    workload: Math.min(Math.max(shaderCount / 25, 20), 200)
                });
            }

            async runGPUTest(testType, shaderCount, params) {
                const program = this.programs[testType];
                if (!program) return 0;

                const duration = 7000; // 7 seconds
                const startTime = performance.now();
                let frameCount = 0;

                this.gl.useProgram(program);
                
                // Set up attributes
                const positionLocation = this.gl.getAttribLocation(program, 'position');
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.quadBuffer);
                this.gl.enableVertexAttribArray(positionLocation);
                this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);

                // Get uniform locations
                const timeLocation = this.gl.getUniformLocation(program, 'time');
                const paramLocation = this.gl.getUniformLocation(program, Object.keys(params)[0]);

                const renderLoop = () => {
                    if (!this.isRunning || performance.now() - startTime >= duration) {
                        return frameCount * shaderCount;
                    }

                    // Set uniforms
                    this.gl.uniform1f(timeLocation, performance.now());
                    this.gl.uniform1f(paramLocation, Object.values(params)[0]);

                    // Render multiple times based on shader count
                    const renderPasses = Math.max(1, Math.floor(shaderCount / 100));
                    for (let i = 0; i < renderPasses; i++) {
                        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
                        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
                        frameCount++;
                    }

                    return new Promise(resolve => {
                        requestAnimationFrame(() => {
                            resolve(renderLoop());
                        });
                    });
                };

                return renderLoop();
            }

            updateStatus(containerId, shaderCount, status) {
                const statusElement = document.getElementById(`${containerId}-${shaderCount}-status`);
                const threadItem = statusElement?.closest('.thread-item');
                
                if (statusElement) {
                    statusElement.textContent = status.charAt(0).toUpperCase() + status.slice(1);
                    statusElement.className = `thread-status ${status}`;
                }
                
                if (threadItem) {
                    threadItem.className = `thread-item ${status}`;
                }
            }

            updateDisplay(containerId, shaderCount, calculations) {
                const calculationElement = document.getElementById(`${containerId}-${shaderCount}`);
                
                if (calculationElement) {
                    if (calculations > 1000000000) {
                        calculationElement.textContent = `${(calculations / 1000000000).toFixed(2)}G`;
                    } else if (calculations > 1000000) {
                        calculationElement.textContent = `${(calculations / 1000000).toFixed(2)}M`;
                    } else if (calculations > 1000) {
                        calculationElement.textContent = `${(calculations / 1000).toFixed(2)}K`;
                    } else {
                        calculationElement.textContent = calculations.toLocaleString();
                    }
                }
            }

            updateProgress() {
                const progress = (this.completedTests / this.totalTests) * 100;
                this.overallProgress.style.width = `${progress}%`;
            }

            updateSummary() {
                this.shaderCounts.forEach(shaderCount => {
                    let total = 0;
                    
                    Object.entries(this.results).forEach(([testType, testResults]) => {
                        if (testResults[shaderCount]) {
                            const rawScore = testResults[shaderCount].calculated || testResults[shaderCount].operations || 0;
                            const normalizedScore = rawScore * this.normalizationFactors[testType];
                            total += normalizedScore;
                        }
                    });
                    
                    const totalElement = document.getElementById(`total-${shaderCount}`);
                    if (totalElement && total > 0) {
                        if (total > 1000000000) {
                            totalElement.textContent = `${(total / 1000000000).toFixed(2)}G`;
                        } else if (total > 1000000) {
                            totalElement.textContent = `${(total / 1000000).toFixed(2)}M`;
                        } else if (total > 1000) {
                            totalElement.textContent = `${(total / 1000).toFixed(2)}K`;
                        } else {
                            totalElement.textContent = Math.round(total).toLocaleString();
                        }
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GPUPerformanceTester();
        });
    </script>
</body>
</html>